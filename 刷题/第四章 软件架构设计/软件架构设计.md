### 知识点

信息隐蔽是开发整体程序结构时使用的法则，通过==信息隐蔽==可以提高软件的==可修改性、可测试性和可移植性==



常见的分层架构的==脆弱性==包括：==底层发生错误会导致整个系统无法正常运行、层与层之间引入通信机制势必造成性能下降==



接口标准化是对==接口中的消息模式、格式和协议==的标准化；



OMG接口定义语言IDL文件包含了六种不同的元素，==接口描述==是一个IDL文件最核心的内容，==模块定义==将映射为Java语言中的包或C++语言中的命名空间；



软件架构设计包括：==提出架构模型、产生架构设计和进行设计评审等活动==，是一个迭代的过程。

架构设计主要关注软件组件的==结构、属性和交互作用==，并通过==视图==全面扫描特定系统的架构；



采用==过程调用架构风格==的系统，可以通过将显式调用策略替换为隐式调用策略能够==提高系统的灵活性==，但是会==降低系统的性能==；



### 软件架构设计基本概念

软件架构为软件系统提供了一个==结构、行为和属性==的高级抽象；

在描述阶段，主要描述直接构成系统的抽象组件以及各个组件之间的连接规则，特别是相对细致地描述组件的==交互关系==；

在实现阶段，这些抽象的组件被细化为实际的组件；软件系统架构不仅制定了软件系统的==组织结构==和==拓扑结构==，而且显示了==系统需求==和==组件==之间的对应关系，包括设计决策的==基本方法==和==基本原理==；



### 软件架构复用

【核心】

软件开发过程中重复使用相同或相似==【软件元素】==的过程。其中，软件元素包含： ==需求分析文档、设计文档、程序代码、测试用例和领域知识等==



【软件架构复用类型】：

- 机会复用：开发过程中，==只要发现有可复用资产==，就对其进行复用；

- 系统复用：开发之前，要==进行规划==，以决定哪些需要复用；

  ​


【软件架构复用的维度】：

- 水平复用：不分行业领域，通用。

- 垂直复用：分行业领域，专用。

  ​

【软件架构复用的主要阶段】：

- 构造/获取可复用的软件资产
- 管理可复用资产
- 使用可复用资产





### 质量属性场景

【核心】

- 场景是从==风险承担者==的角度对系统交互的简短描述，它通常作为==描述质量属性的手段==。
- 场景可从六个方面进行描述：刺激源、==刺激==、制品、==环境==、==响应==、响应度量。




### 架构评估方法

#### 架构评估方法 -- SAAM

【核心】

- 基于场景的架构分析方法（SAAM）的主要输入是==问题描述、需求说明及架构描述==;
- SAAM的过程包含五个步骤：==场景开发、架构描述、单个场景评估、场景交互及总体评估==；



#### 架构评估方法 --- ATAM

【核心】

- 权衡分析方法（ATAM）包含4个主要的活动领域【阶段】：==场景和需求收集、架构视图和场景实现、属性模型构造和分析、折中==；

- ATAM：在==SAAM的基础==上发展起来的，该框架主要关注系统的==需求说明==，针对==性能、可用性、安全性和可修改性== ，该方法要求系统在开发之前，首先对这些==质量属性==进行==评价==和==折中==；

  ​



【评估工具】

==效用树==采用架构权衡分析方法（ATAM）进行架构评估的工具之一，==对质量属性的描述进行刻画与排序==，其树形结构从根部到叶子节点依次为：

==树根、质量属性、属性分类、质量属性场景==

【效用树】

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509102214100.png)



【ATAM描述】

- ATAM需要对软件质量属性进行==优先级排序==；
- ATAM==不是==一种精确的评估工具；



### 软件系统质量属性

【运行期间质量属性】

- 可伸缩性：指当用户数和数据量增加时，软件系统维持高服务质量的能力。例如：通过增加服务器来提高能力。
- 可靠性：在一定的时间内无故障运行的能力。
- 持续可用性：指系统长时间无故障运行的能力。
- 鲁棒性（健壮性、容错性）：指软件系统在一些非正常情况下（如用户进行了非法操作、相关的软硬件系统发生了故障等）下仍能够正常运行的能力。
- 性能：指系统的响应能力：即经过多长时间才能对某个时间做出响应，或者在某段时间内系统所能处理事件的==个数==。


【开发期质量属性】

- 可重用性：指重用软件系统或某一部分的难易程度。
- 可修改性：可维护性、可扩展性、可移植性及==结构重构==都属于可修改性需要考虑的内容。
- 可测试性：系统应该提供一个开放的API接口，支持远程对系统的行为进行控制与==调试==。（注：这个不是代表的不是互操作性，而是可测试性，目的是为了调试而不是交互）


### 特定领域架构（DSSA）

【核心】

特定领域软件架构以一个==特定问题领域==为对象，行成由==领域参考模型、参考需求、参考架构==等组成的开发基础架构，支持一个特定领域中==多个应用的生成==。



【DSSA基本活动及产物】

- 领域分析：建立==领域模型==
- 领域设计：获取==特定领域架构（DSSA）==
- 领域实现：开发和组织==可复用信息==




【DSSA类型】

- 垂直域：相同领域，深入
- 水平与：不同领域，平移




【DSSA角色划分】

- 领域专家：==软件工程师==担任；提供关于领域中系统的==需求规约==和==实现知识==；

- 领域分析人员：==系统分析人员==担任；控制==整个领域分析过程==，进行知识获取，将获取到的知识组织到领域模型中。

- 领域设计人员：==软件设计人员==担任；根据==领域模型和现有系统开发出DSSA==，并对DSSA的准确性和一致性进行验证。

- 领域实现人员：==程序设计人员==担任；根据==领域模型和DSSA==，==建立==DSSA与可重用构件间的==联系==；

  ​


【DSSA三层次模型】

- 领域开发环境：==领域架构师==；
- 领域特定的应用开发环境：==应用工程师==；
- 应用执行环境：==操作员==；




### 基于架构的软件开发方法（ABSD）

【核心】

ABSD方法是==架构/体系结构==驱动，即强调由==业务(商业)、质量和功能需求==的组合驱动架构设计;

ABSD视角与视图来==描述软件架构==，用例用来==捕获功能需求==，质量场景【刺激、环境、响应】用来==捕获质量需求==；

【基础】

ABSD方法三个基础

- 对系统==功能进行分解==；
- 通过选择==架构风格==来实现质量和业务需求；
- 采用==软件模板==设计软件结构；



【ABSD开发过程】

- ABSD能很好的==支持软件重用==；
- ABSD方法是一个==自顶向下、递归细化==的方法；
- 软件系统的体系结构通过该方法得到细化，直到能产生==软件构件或类（软件构件或模块）==；



ABSD过程划分：==架构需求、架构设计、架构文档化、架构复审、架构实现、架构演化==6个子过程。

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509102257793.png)

【ABSD开发过程 --- 架构需求】

架构需求用于==激发和调整设计决策==，不用的视图被用来表达与质量目标有关的信息；



【ABSD开发过程 --- 架构设计】

架构设计是一个==迭代过程==，在建立软件架构的初期，首要任务是选择一个合适的==架构风格==，在此基础上，开发人员通过架构模型，可以获得关于==架构属性==的理解，为将来的架构实现与演化过程建立了目标；



【ABSD开发过程  --- 架构文档化】

架构文档化过程的主要输出结果是：==架构规格说明==和==测试架构需求的质量设计说明书（架构质量说明书）==；文档的==完整性==和==质量==是软件架构成功的关键因素；

架构文档的三大注意事项：

- 文档要从==使用者角度==进行编写；
- 必须分发给==所有==与系统有关的开发人员，针对不用背景的人员书写文档的方式不同；
- 必须保证开发者手上的文档是==最新的==，但是需要注意==不是随时==保证文档是最新的，要==保持文档的稳定性==；




【ABSD开发过程 -- 架构复审】

架构复审【架构评估】的目的是==标识潜在的风险==，及早发现架构设计中的缺陷和错误；

在架构复审种，主要由==用户代表与领域专家==决定架构是否满足需求、质量需求是否在设计种得到体现等方面；



【ABSD开发过程 --- 架构实现】

所谓”实现“就是要==用实体来显示出一个软件架构==，即要符合架构所描述的结构性设计决策，分割成规定的构件，按规定方法互相交互；



【ABSD开发过程 --- 架构演化】

==针对用户的需求变化，修改应用架构，满足新的需求==；



### 软件架构之多视图（“4+1”视图）

【视角与视图】

- 从不同的视角来检查，所有会有不同的视图。
- 从不同的视角来检查，这促使软件设计师考虑架构的不同属性。例如：展开功能组织的==静态视角==能判断质量特性，展开并发行为的==动态属性==能判断系统行为特性。



【核心】

- 多视图是一种描述软件架构体系结构的重要途经，其体现了==关注点分离==的思想；
- “4+1”视图模型从==逻辑视图、进程/过程视图、实现/开发视图、配置/物理/逻辑视图以及场景==来描述软件架构；在该模型中“4指的是四个视角的视图，“1”指的是场景；

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509110916926.png)

【视图特点】

- 逻辑视图：描述设计中对象和类之间的关系，设计元素的功能和概念接口；
- 进程/过程视图：描述设计中性能、可伸缩等问题，捕捉设计的并发和同步特征；
- 实现/开发/模块视图：描述系统的配置、装配等问题，描述在开发环境中软件的静态组织结构；
- 配置/物理/部署视图：描述系统发布、安装等问题，计算机网络中的节点；




### 构件

【核心】

在构件的定义中，==接口==是一个已命名的一组操作的集合；



【构件特性】

- 构建是==独立部署单元==；
- 构件的部署必须能跟它所在的环境及其他构件==完成分离==；
- 构件可作为==第三方的组装单元==；
- 构件==没有外部的可见状态==；
- 构件作为一个部署单元是==不可拆分的==；
- 在一个特地给进程中可能会存在多个特定构件的拷贝；





【服务端构件标准】

- 应用服务器：EJB模型和COM+模型；
- Web服务器：servlet模型个Visual Basic及其他微软的技术（ASP技术）；
- NET框架引入了一种新的同时适用于客户端和服务端的基于CLI的构件模型；




【构件分类】

如果把软件系统看成是构件的集合，那么从==构件的外部形态==来看，构成一个系统的构件可以分为5类：

- 独立而成熟的构件：经过了实际运行环境的多次检验，该类构件==隐藏了所有接口==，用户只需用规定好的命令进行使用（例如：数据库管理系统和操作系统等）；
- 有限制的构件：提供了接口，指出了使用的条件和前提，这种构件在装配时，==会产生资源冲突、覆盖等影响==，在使用时需要加以测试（例如：各种面向对中的基础类库）；
- 适应性构件：进行了包装或使用了接口技术，把==不兼容性、资源冲突等进行了处理==，可以==直接使用==（例如：ActiveX等）；
- 装配的构件：装配的构件在安装时，已经装配在操作系统、数据库管理系统或信息系统不同层次上，==使用胶水代码就可以进行连接使用==，目前一些软件商提供的大多数软件产品都属于这一类；
- 可修改的构件：可修改的构件可以进行==版本替换==，如果对原构件修改错误、增加新功能，可以利用重新“包装”或写接口来实现构件的替换，这种构件在应用系统开发中使用得比较多；




【构件的组装】

- 基于功能的组装：侧重于根据软件系统的功能需求来组装构件；
- 基于数据的组装：首先根据当前软件问题的核心数据结构设计一个框架，然后根据框架中各个节点的需求提取构件并进行适应性修改。
- 面向对象的构件组装：面向对象中存在封装、继承和多态等特性，这些特性使得面向对象比其他软件开发方法更适合支持软件复用。




【构件组装成软件系统可以分为三个不同层次】

- 定制：根据==特定需求==对构件进行==个性化调整==；
- 集成：将多个定制好的构件==组合==成一个完整的软件系统；
- 扩展：在现有软件系统的基础上==增加新的功能==；




【构件组装失配问题】

- 由构件引起的失配：由于系统对构件==基础设施、控制模型和数据模型==的假设存在冲突引起的失配；
- 由连接子引起的失配：由于系统对构件==交互协议、连接时数据格式==的假设存在冲突引起的失配；
- 由于==系统成分对全局体系结构==的假设存在冲突引起的失配；



【构件分类方法】

- 关键字分类法：根据==领域分析的结果==将应用领域的概念按照==从抽象到具体的顺序==逐次分解为==树形或有向无回路图结构==；
- 刻面分类法：==利用Facet描述构件执行的功能==、被操作的数据、构件应用的语境或任意其他特征；（例如：分为多个刻面：应用领域、使用环境、功能）
- 超文本方法：使得检索者在阅读文档过程中可以按照人类的联想思维方式任意跳转到包含==相关概念或构件的文档==。




【三大构件标准】

- CORBA
- J2EE：
  - 会话Bean（会话型构件）：负责==完成服务端与客户端的交互==；
  - 实体Bean（实体型构件）：用于==数据持久化==来简化数据库开发工作；
  - 消息驱动Bean（消息驱动构件）：主要用来==处理并发和异步访问操作==；
- DNA2000




【构件标准 --- CORBA技术】

构件的标准使用CORBA技术，CORBA服务端构件模型中：

- 伺候对象（Servant）：==CORBA对象的真正实现==，负责==完成客户端请求==；
- 对象适配器（Object Adapter）【可移植对象适配器POA】：==POA==是对象实现与ORB其他组件之间的中介，用于==屏蔽ORB内核的实现细节==，为服务器对象的实现者==提供抽象接口==，对象实现之间进行==协调==；
- 对象请求代理（Object Request Broker）：==解释调用并负责查找实现该请求的对象==；




### 面向构件编程（COP）

【核心】

面向构件编程（COP）关注于如何支持建立面向构件的解决方案；面向构件的编程所需要的==基本支持==包括：

- 多态性：可替代性；
- 模块的封装：高层次信息的隐藏；
- 后期的绑定和装载：部署独立性；
- 安全性：类型和模块安全性；




### 中间件

【核心】

- 使用中间件有助于提高开发效率；

- 使用中间件==将降低应用软件设计==的复杂度（注：对于设计方面确实是简单了）；

  ​

【中间件类型】

- 分布式中间件：主要==由一组对象来提供系统服务==，对象间能够跨平台通信。
  - 交互支持：中间件==协调系统中的不同组件之间的交互==；
  - 提供公共服务：中间件==提供对服务的可复用的实现==；
- 消息中间件：是消息传输过程中==保存消息的一种容器==。
- 基于远程过程调用（RPC）中间件：允许一个应用程序中的过程调用远程应用程序中的过程，就好像它们本地调用一样。




【中间件作用】

- 负责==客户机与服务器之间的连接和通信==，以及==客户机与应用层之间按的高效率通信机制==；
- 提供==应用的负载均衡和高可用、安全机制与管理功能==，以及==交易管理机制，保证交易的一致性==；
- 提供应用层不同服务之间的==互操作机制==，以及==应用层与数据库之间的连接和控制机制==；
- ==屏蔽==硬件、操作系统、==网络和数据库的差异==；
- 提供==一组通用的服务去执行不同的功能==，避免重复工作，使应用之间可以协作；




#### 消息中间件


【消息中间件定义】

消息中间件是在==消息的传输过程中保存信息的容器==。

【消息中间件特点】

- 采用==异步处理==模式；
- 应用程序和应用程序调用关系为==松耦合关系==；



【消息中间件传输模式】

- 点对点模型：点对点模型用于==消息生产者和消费者之间点到点通信==；
- 发布-订阅模型：发布-订阅模型支持==向一个特定的消息主题生产消息==；




### 微服务

【核心】

微服务架构使用==去中心化==的管理方式，每个服务都是一个独立的应用程序，独立管理、使用独立的数据库、独立部署和独立运行。面向服务架构（SOA）是一种整体式架构，使用==集中式==的管理方式和==统一的数据中心==。



### 面向服务架构（SOA）

【核心】

- 面向服务架构（SOA）是一种整体式架构，使用==集中式==的管理方式和==统一的数据中心==；
- 微服务是SOA技术的一种变体；
- SOA常用的设计模式是==服务注册表模式==和==企业服务总线ESB模式==；



【SOA优势】

这种交互过程不再是点对点的==直接交互模式==，而是由==事件驱动的消息交互模式==；最大限度降低了模块之间的==耦合关系==；但是二者之间仍然存在关系，只不过是松耦合的；



### 数据资产

【核心】

日常生活中，数据无处不在，但==并不是所有的数据都可以成为资产==；数据作为资产==必须包含==以下特征：==可控制、可量化、可共享、可增值==。所以数据资产一般具有：==虚拟性、共享性、时效性、安全性质、交换性和规模性==。



### CS架构

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509111732780.png)

针对二层C/S软件架构的缺点，三层C/S架构应用而生。在三层C/S架构中，增加了一个==应用服务器==。

三层C/S架构是将应用功能分成：==表示层、功能层、数据层==三个部分。其中==表示层==是应用的用户接口部分，担任与应用逻辑间的对话功能。



### 架构风格

【核心】

- 架构风格描述某一特定领域中系统组织方式和惯用模式，一个体系结构定义了==一个词汇表==和==一组约束==，反映了领域中众多系统所共有的==结构和语义==特征，强调对==架构设计==的重用；
- 软件架构风格定义了一类架构所共有的特征，主要包括：==架构定义、架构词汇表和架构约束==
- ​



【架构风格分类 ”五大类“】

- 数据流风格【Date Flow】：必须等待前一步的处理完之后进入下一步，并且前一步的输出内容是下一步的输入。==“数据驱动“==

  - 批处理【Batch Sequential】：大量==整体数据==、无需用户交互

  - 管理-过滤器【Pips and Filters】：==流式数据，并行处理==、弱用户交互

    ​

- 调用/返回风格【Call/Return】：==调用子函数，返回执行结果，构件之间直接交互，紧耦合==

  - 主程序/子程序【Main Program and Subroutine】：==面向过程==

  - 面向对象【Object-oriented】：==面向对象，对象的方法调用==

  - 分层架构【Layer System】：==层与层之间的方法调用==，例如：物联网（感知层、网络层、应用层）

    ​

- 独立构件风格【Independent  Components】：存在==事件管理机制==，主函数==触发事件==告诉事件管理机制，事件管理机制==通知执行==子函数，子函数执行结果也必须通过事件管理机制返回。==构件之间不直接交互，松耦合==

  - 进程通信【Communicating Processes】：==同步==

  - 事件驱动系统（隐式调用）【Event System】：==异步==

    ​

- 虚拟机风格：Java虚拟机==可跨平台==，因为在每个平台上都存在不同的Java虚拟机（Windows虚拟机、Linux虚拟机..）

  - 解释器【Interpreter】：适用于需要==”自定义规则”==的场合

  - 规则系统【Rule-base System】：在解释器的基础上增加==经验规则==，适用于==专家系统==

    基于规则的系统包括：==规则集、规则解释器、规则/数据选择器及工作内存==。

    ​

- 以数据为中心（数据仓库）：数据作为中心仓库，全部围绕这个==数据仓库==进行（==编辑器集成==）

  - 数据库系统【Database System】：==以数据为中心，存储、管理和检索数据==
  - 黑板系统【Blackboard System】：==语音识别、模式识别、图像处理、知识推理==
  - 超文本系统【Hypertext System】：==以超文本（包含文本链接）形式组织和呈现数据==




### 仓库风格

【核心】

- 以数据为中心（例如：数据库系统、黑板系统、超文本系统）
- 在仓库风格中，有两种不同的构件，其中，==中央数据结构==说明当前状态，==独立构件==在中央数据存储上执行。

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/20250911210615906.png)





### C2风格

【核心】

C2架构风格可以概括为：通过==连接件==将一组==构件==按照一定的规则连接到一起；

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/20250911224920549.png)

C2架构的基本规则：

- 构件和连接件都有一个顶部和一个底部；
- 构件的顶部要链接到连接件的底部，构件的底部要链接到连接件的顶部，构件之间不能直接相连；
- 一个连接件可以和和任意数目的构件和连接件链接；
- 当两个连接件进行直接相连时，必须由其中一个的底部到另一个的顶部；




### 基于服务架构（SOA）

【Web Service （WEB服务）】

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509120913368.png)

- UDDI：用于Web==服务注册和查找==；
- WSDL：用于==描述Web服务的接口和操作功能==；
- SOAP：为建立Web服务和服务请求之间的通信==提供支持==，用于实现Web服务器的==远程调用==；
- BPEL：可以将多个Web服务==组合==成一个新的复合服务；




### 架构描述语言ADL

【核心】

ADL是一种==形式化==语言，其基本构成要素包括：==组件、组件接口、连接件、架构配置==；



### 案例题

#### 案例一

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509111835517.png)

分析：数据传递时延迟不大于1s，并提供相应的优先级管理。关键点：延迟肯定是和性能有关系，但是后边提及==优先级管理==，那么就必须使用==资源仲裁==更加合适，否则使用==资源调度==

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509111838108.png)





#### 案例二

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/20250911212814847.png)



#### 案例三

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509120932675.png)

分析：

A：==构件是一组通常需要同时部署的原子构件==；

B：构件可以单独部署，原子构件也可以单独部署，只是==常常不单独部署==而已；

C：原子构件是==不可以==在多个构件家族中==共享==的；

D：一个原子构件是由==一个模块==和==一组资源==组成的。所以，一个模块可以看作是==不带有资源==的原子构件；



#### 案例四

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509121128336.png)

注：现代==编译器的集成开发环境==一般采用==【数据仓库】（即以数据为中心的架构风格）==架构风格进行开发，其中数据就是程序的语法树；



#### 案例五

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509121632757.png)

注：本题考查的是==软件结构设计与生命周期==

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509121637256.png)

A与B选项：是==【设计阶段】==需要考虑的问题；

C选项：是==【需求分析阶段】==需要考虑的问题；

D选项：是==【实现阶段】== 需要考虑的问题；



#### 案例六

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509121644448.png)

注：==软件架构设计不能捕获需求==，软件架构设计是在需求捕获并进行分析之后开展的工作；



#### 案例七

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509121820940.png)

