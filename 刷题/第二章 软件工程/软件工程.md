## 第三章 软件工程

**知识点**

==需求抽取和分析==的过程主要分为四个步骤：

1. 需求发现和理解；

2. 需求分类和组织；

3. 需求优先级排序和协商；

4. 需求文档化；

   ​



软件复杂性度量中，==环路数==可以反应源代码结构的复杂度。

==程序图的环路数是源代码复杂度的度量==。环路复杂度是一种代码复杂度的衡量标准，目标是为了指导程序员写出更具可测性和可维护性的代码。



工作流表示的业务过程模型，通常使用图形形式来描述，注意：==用例图==不可以用来描述工作流。



结构化建模方法：以==过程为中心==的技术，可用于分析一个现有的系统以及定义新系统的业务需求，结构化建模方法的基本工具是==数据流图（DFD）==。



信息化建模方法：从数据的角度对现实世界简历模型，模型是现实系统的一个抽象，信息化建模方法的基本工具是==实体联系图（ERD）==。

面向对象建模方法：将“数据”和“过程”集成到被称为“对象”的结构中，消除了数据和过程的人为分离现象。面向对象建模方法所创建的模型被称为对象模型，后面形成了面向对象的建模标准，即UML（统一建模语言）。



软件过程是制作软件产品的一组活动及结果。这些活动主要由软件人员来完成，软件活动主要包括：==软件描述、软件开发、软件有效验证和软件演化==。其中，==软件描述==定义了软件功能及使用的限制。



软件设计包含四个既独立又相互联系的活动：==数据设计、软件结构设计、人机界面/接口设计和过程设计==。

- 数据设计：==将模型转换成数据结构的定义==。高质量的数据设计将改善程序结构和模块划分，降低过程复杂性


- 结构设计： 定义软件==系统各主要部件之间==的关系。
- 人机界面/接口设计：描述了==软件与用户之间==的交互关系。
- 过程设计：系统==结构部件转换成软件==的过描述。



根据传统的软件生命周期方法学，可以把软件生命周期划分为：==软件定义、软件开发、软件运行以及软件维护==，可行性研究属于==软件定义==阶段的主要任务。



软件概要设计包括：==设计软件的结构、确定系统功能模块及其相互关系==，主要采用==模块结构图、层次图和HIPO图==描述程序的结构。



软件开发环境支持多种集成机制。集成根据==功能的不同==，可划分：

- 环境信息库：用于存储与系统开发有关的信息，并支持信息的交流与共享。
- 过程控制与消息服务器：是实现过程集成和==控制集成==的基础。
- 环境用户界面：包括环境总界面和由它实行统一控制的各环境部件及==工具的界面==。





软件开发环境由==软件工具集==和==环境集成机制==构成。

- 软件系统工具的种类繁多，按照软件过程活动将软件工具分为：==软件开发工具、软件维护工作、软件管理工作和软件支持工作==。
- 环境集成机制：
  - 数据集成机制：提供==统一的==数据模式和数据接口==规范==；
  - 控制集成机制：支持==各开发活动==之间的通信、切换、调度和协同；
  - 界面集成机制：为==统一操作方式==提供支持；





需求陈述：

- 每一项需求记录的功能都必须是用户真正需要的。
- 需求是==存在优先等级==的，不能把所有的需求都==视为同等==重要。




当采用面向对象的设计方法描述对象模型时，通常采用==类图==表达类的内部属性和行为，以及类集合之间的交互关系；采用==状态图==定义对象的内部行为；

- 对象图：描述一组对象及它们之间的关系，描述类图中所建立的事务实例的==静态快照==；
- 活动图：将进程或其他计算结构展示为计算内部一步步的控制流和数据流；==专注于系统的动态视图==；
- 状态图：描述一个状态机，它由状态、转移、事件和活动组成，定义对象的内部行为，==专注于对象的动态视图==；
- 类图：表示==类的内部属性和行为==，以及类集合之间的交互关系；



### 系统输入设计

系统输入设计中，采用==内部控制==方式以确保输入系统数据的有效性；

- 数据类型检查：确保输入==正确的数据类型==；
- 自检位：对==关键字==进行基于校验位的检查；
- 域检查：验证数据是否位于==合法的取值范围==；
- 格式检查：按照已知的数据格式对照检查==输入数据的格式==；



### 软件方法学/软件开发方法

软件方法学是以软件开发方法为研究对象的学科。

从==开发风格==上看，分为自顶向下开发方法和自底向上开发方法。

- ==自顶向下==：先对最高层次中的问题进行定义、设计、编程和测试，而将其中未解决的问题作为一个子任务放到==下一层==中去解决。
- ==自底向上==：从==具体的器件、逻辑部件==或者相似系统开发，通过对其进行相互链接、修改和扩大，构成所需求的系统。

从==性质==上看，分为形式化方法和非形式化方法。

- ==形式化方法==：一种具有坚实数学基础的方法。
- ==非形式化方法==：不把严格性作为其主要着眼点，通常以各种开发模型的形式得以体现。


![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509100915427.png)

注：

- 使用形式化方法开发大型应用时，往往过于细节化，难以让用户和开发人员理解，故==大型应用不适合形式化开发==。
- 净室软件工程（CSE）是软件开发的一种形式化方法，可以开发较高质量的软件。



传统软件方法学==采用结构化设计==方法，从工程管理角度结构化设计分为两步：

1. 概要设计：将软件需求转化为==数据结构==和==软件系统结构==。
2. 详细设计：过程设计，通过对结构细化，得到软件详细==数据结构==和==算法




### 软件需求工程

软件需求是指==用户对系统==在功能、行为、性能、设计约束等方面的==期望==。



![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509042204351.png)

需求工程主要活动的阶段划分：

1. ==需求开发==：需求获取、需求分析、形成需求规格、需求确认与验证【形成“需求基线”】
2. ==需求管理==：变更控制（需求变更管理的过程主要包括：问题分析和变更描述、变更分析和成本计算、变更实现）、版本控制、需求跟踪（编制每个需求与元素之间的联系文档）、需求状态跟踪。



软件需求管理是对==【需求基线】==管理（也可以说：需求管理是一个对==系统需求==及其==变更==进行==了解==和==控制==的过程），在需求管理中，要求维持对用户原始需求和所有产品构件需求的==双向跟踪==。



软件==需求开发==的最终文档经过评审批准后，就定义了开发工作的==需求基线==，它在客户和开发者之间构筑了产品功能需求和非功能需求的一个==需求约定==，是需求来发和需求管理之间的桥梁。



为了获得项目，开发人员==不可以==先向客户做出某些承诺；



![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/20250909204556724.png)

注：

- 根据软件成熟度模型（CMM），为达到过程能力成熟度模型第二级，组织机构必须具有6个关键过程域。
- 需求变更的管理过程遵循：问题分析和变更描述、变更分析和成本计算、变更实现的顺序。





自动化工具能够帮助==变更控制过程==更有效地运行，这类工具的特征：

- 可以定义变更请求中的数据项。
- 可以定义变更请求生命周期的状态转换模型。
- 可以强制实施状态转换模型，以便只有授权用户可以做出允许的状态变更。
- 可以记录每一个状态变更的日期和做出这一变更的人。
- 可以定义当提议者提交新请求或请求状态被更新时，那些人可以自动接收电邮箱通知。
- 可以生成标准的、定制的报表和图标。





### 结构化需求分析

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509092159833.png)

**功能模型：数据流图（DFD）示例**

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202507101038899.png)

**行为模型：状态转换图（STD）示例**

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202507101041916.png)

**数据模型：E-R图示例** 

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202507101044552.png)

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202507101117954.png)



### UML需求分析

基于UML的需求分析过程的基本步骤为：

1. 利用==用例及用例图==表示需求；
2. 利用==包图及类图==表示目标软件系统的总体架构。





### 需求获取

【需求分类】

需求分为==软件需求==和==系统需求==

【需求获取方法】

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509092214839.png)

JRP是一种相对来说成本较高的需求获取方法（而非对需求进行分析和验证），但也是十分有效的一种。



### 需求跟踪

核心：==用户原始需求、软件需求、下游工作产品==

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509101653046.png)





### 人机界面设计

黄金三法则：==置于用户控制之下、减少用户的记忆负担、保持界面的一致性==



### 软件工程模型之增量式开发

【增量式开发】

将最终产品==分解==成一系列较小、功能相对完整的模块或者部分（增量）。每个增量都构建在前一个增量的基础上。

与瀑布模型相比，==增量式开发==降低了实现需求变更的成本，更容易得到客户对于已完成开发工作的反馈建议，并且客户可以更早地使用软件并从软件中获得价值。

【迭代式开发】

==重复循环/迭代==整个开发过程（设计 --> 构建 --> 测试 --> 评审）。每次迭代，都针对产品的整体或部分进行改进、优化。早期迭代可能只关注核心或粗糙版本，后续迭代不断精化。

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509042149999.png)





### 软件工程模型之螺旋模型

螺旋模型以==快速原型为基础+瀑布模型==，考虑了==风险==问题。

==螺旋模型==将整个开发流程分为（按顺序执行）：==目标设定、风险分析、开发和有效性验证、评审==四个部分；

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509050849783.png)



### 软件工程模型之构件模型

【核心】

- ==构件模型==通过==重用==来提高软件的可靠性和易维护性，程序在进行修改时产生较少的副作用。
- 基于构件的软件开发中：
  - ==逻辑构件模型==：描述系统设计蓝图以保证系统提供==适当功能==。
  - ==物理构件模型==：了解系统的性能、吞吐率德国==非功能性属性==。

【阶段】

基于构件的开发模型包括：==需求分析定义、体系结构设计、构件库建立、应用软件构件以及测试和发布==五个阶段。

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509050851361.png)



### 软件工程模型之敏捷开发

敏捷开发是一种以“人”为核心、迭代、循序渐进的开发方法；

敏捷开发是适应性而非预设性；

敏捷开发采用迭代增量式的开发过程，发行版本小型化；

敏捷开发中强调开发过程中相关人员之间的信息；

敏捷开始是”面向对象“的，而非”面向过程“的；



【其他敏捷开发方法】

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509092206221.png)



### 软件工程模型之统一过程/开发过程模型（RUP）

核心：

- 采用==迭代式开发==，在每一轮迭代中都要进行测试和集成。
- 使用==用例驱动==。

阶段和特点：一个开发周期包含：==初始、细化、构造、移交==四个阶段。==设计及确定系统架构是细化阶段的任务==

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509082242394.png)



核心工作流：

RUP软件卡覅生命周期是一个二维的软件开发模型，RUP的9个核心工作流：==商业（业务）建模、需求、分析和设计、实现、测试、部署、配置和变更管理、项目管理以及环境==。



RUP强调采用==迭代和增量==的方式来开发软件，这样做的好处是：==在软件开发的早期就可以对关键的、影响大的风险进行处理==。



### 软件工程模型之逆向工程

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509090910029.png)

（1）重构/重组：重构是指在==【同一抽象级别上】== 上 【转换系统描述形式】。

（2）设计恢复：设计恢复是指借助工具从==已有程序中抽象出有关数据设计==、总体结构设计和过程设计等方面信息

（3）逆向工程：可以将软件某种形式的描述转换为==更高级的抽象表现形式==，==逆向工程是设计的恢复过程==。

（4）正向工程：正向工程是指不仅从现有系统中恢复设计信息，而且==使用该信息去改变或重构现有系统，以改善其整体结构==。

（5）再工程/重构工程：对现有系统的重新开发，包括逆向过程、新需求的考虑过程和正向工程三个步骤，产生一系统的一个==新版本==。



逆向工程导出信息的四个抽象层次：

- 实现级：包括程序==抽象语法树、符号表、过程==的设计表示。
- 结构级：包括反应==程序分量之间相互依赖关系==的信息。
- 功能级：包括反应==程序段功能及程序段==之间关系的信息。
- 领域级：包括反应程序分量或程序实体与==应用领域概念之间对应关系==的信息。





### 软件工程模型之模块化设计

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509090929655.png)

注：==模块的接口==是模块与其他模块进行交互的部分，所以接口的定义不仅仅属于其模块自身的内部特性，与==外部模块也具有相关性==。



### 软件工程模型之结构化设计

结构化设计原则：

- 模块独立性原则（高内聚，低耦合）
- 保持模块大小适中
- 多扇入，少扇出
- 深度和宽度均不宜过高




结构化设计包括==架构设计、接口设计、数据设计以及过程设计==等任务。



==传统软件方法学==采用结构化设计方法，从工程管理角度结构化设计分为两步：

1. 概要设计（外部设计）：将软件需求转化为==数据结构==和==软件系统结构==，设计各个部分的功能、接口及相互如何关联。
2. 详细设计（内部设计）：过程设计，通过对结构细化，得到软件详细==数据结构==和==算法==，设计具体一个模块的实现。




结构化程序设计采用==自顶向下、逐步求精及模块化==的程序设计方法，通过==顺序、分支和循环==三种基本的控制结构可以构造出任何单入口单出口的程序。



【结构化设计基本过程】

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509100932367.png)

注：需要记住结构化设计基本过程包含两个模型：==分析模型==和==设计模型==，并且需要记住每个环节使用什么图表示。

设计模型包含：以==包图==表示的软件体系结构图（架构图）、以==交互图==表示的用例实现图、完整精准的类图、描述复杂对象的==状态图==和用以描述流程化处理过程的==活动图==。



### 软件工程模型之快速应用开发模型（RAD）

- 系统模块化程度较高时，采用快速应该开发模型，该方法通过使用==基于构件==的开发方法获得快速开发。

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509091716917.png)



### 软件工程模式之原型模型

原型模型两个核心阶段：==原型开发阶段==和==目标软件开发阶段==

原型开发分为两大类：

快速原型法（抛弃型原型）：==快速开发出一个原型==，利用该原型获取用户需求，然后将该原型==抛弃==；

演化式原型法：将原型==逐步进化==为最终的目标系统。



![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509091722000.png)



### 软件工程模型之分析/设计模型

面向对象的分析模型主要由：==顶层架构图、用例与用例图和领域概念模型==构成；



### 遗留系统处置策略

遗留系统处置策略可以采用：==集成、改造、淘汰、继承==四种方式。

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509041958928.png)



### **软件测试**



软件测试阶段，测试阶段：

【核心】

==单元测试==：依据【详细设计】，模块测试，模块功能、性能、接口有等 （==关键点：模块内部测试==）。

==集成测试==：依据【概要设计】，模块间的接口（==关键点：模块之间的协作性==）。从==组装策略==分类，分为==一次性组装==和==增量式组装==。集成测试计划通常在==概要设计==阶段完成，集成测试一般采用==黑盒测试==方法。

==系统测试==：依据【需求文档】，包括功能测试、性能测试、压力测试等（==关键点：整个系统级别测试==）。

【其他测试】

==确认测试==：依据【需求文档】，验证软件与需求的一致性。根据==用户参与程度==不同，软件确认测试通常包含：==内部确认测试、Alpha测试、Beta测试及验收测试==等（==关键点：验证软件与需求的一致性【比如：软件功能、性能及其特性是否与用户需求一致】==）。

==AB测试==：多版本同时使用，利用收集各版本的用户反馈，评估出最好版本（==关键点：多版本同时使用==）。

==Web测试==：Web系统测试与其他系统测试内容基本相同，只是侧重点不同。包含：源代码规则分析、链接测试、框架测试、表格测试等。

==连接测试==： 测试所有链接是否按照被指示的那样确实链接到了该链接的页面；测试所有链接的页面是否都存在；保证Web应用系统上没有孤立的页面（==关键点：主要是针对前端页面/链接测试==）。

==表单测试==：验证服务器是否能正确保存这些数据，后台运行的程序能否正确解释和使用这些信息。测试提交操作的完整性（==关键点：主要是针对后端程序的测试==）。

==回归测试==：测试软件变更之后，变更部分的正确性和对变更需求的符合性（==关键点：针对变更部分进行测试==）。



软件测试类型：

- 以测试过程中==程序执行状态==为依据分类：
  - ==动态测试==：计算机运行程序（3步骤：构造测试实例、执行程序以及分析结果）。
  - ==静态测试==：人工监测和计算机辅助分析（桌前检查、代码审查以及代码走查）。
- 以==内部结构是否可见性==为依据分类：
  - ==白盒测试【结构测试】==：关注内部结构和逻辑。
  - ==黑盒测试【功能测试】==：关注输出输出及功能。




在静态测试中，主要针对程序代码进行静态分析，静态分析方法：

- 控制流分析：是否存在没有使用的语句/==无法到达的语句==/调用并不存在的子程序。
- 数据流分析：==引用未定义的变量==、对以前未使用的变量再次赋值。
- 接口分析：模块之间==接口的一致性==、子程序和函数之间的接口一致性、函数形参与实参的数量、顺序、类型的一致性。
- 表达式分析：==括号不配对==、数据引用越界、除数为零。
- 信息流分析：找出==输入变量==和==输出变量==之间的==依赖关系==。
- 路径分析：找出==程序中所有可能的路径==并画出在此路径中==执行的语句==。




 ![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/20250909211904382.png)

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/20250909211940423.png)

自顶向下：驱动模块、被测模块以及庄模块。



### 白盒测试与黑盒测试

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509042050489.png)

白盒测试中，==路径覆盖==测试强度是最高的；

黑盒测试法主要根据==程序外部功能==来设计测试用例；

==组合覆盖主要特点==： 要求设计足够多的测试用例，使得每个判断中条件结果的所有可能组合==最少出现一次==；



### 人工测试与自动化测试

【人工测试】：纯靠人工手动一步步进行测试。

【自动化测试】：先写脚本 --> 自动化执行；不适合场景：项目周期短，需求变动频繁；常见自动化测试：单元自动化测试、接口自动化测试、UI自动化测试。

自动化测试工具主要使用脚本技术来生成测试用例：

==线性脚本==： 录制手工测试的测试用例时得到的脚本；

==结构化脚本==： 结构化程序设计，具有各种逻辑结构、函数调用功能。

==共享脚本==：共享脚本是指可以被多个测试用例使用的脚本，也允许其他脚本使用。

==数据驱动脚本==： 将测试输入存储在独立的数据文件中，而不是在脚本中。

==关键字驱动脚本==：关键字驱动脚本是数据驱动脚本的逻辑扩展。它将数据文件变成测试用例的描述，采用一些关键字指定要执行的任务。





### 软件性能测试

软件性能测试有多种不同类型的测试方法

- ==强度测试==：是在系统资源特别低的情况下考查软件系统==极限运行情况==。
- ==负载测试==：用于测试==超负荷环境中==程序是否能够承担，确定在各种工作负载下系统的性能，测试当负载逐渐增加时，系统各项性能指标的变化情况。
- ==压力测试==：通过确定系统的瓶颈或不能接收的性能点，来获得系统能够提供的==最大服务级别==的测试。
- ==容量测试==：并发测试也成为容量测试，主要用于测试系统可同时处理的在线==最大用户数量==。
- ==恢复测试==：检查系统的容错能力。





### 设计模式

设计模式是一套可以被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且提高代码的可靠性。

根据==目的==分类：

- 创建型：主要用于创建对象（共5种）。
  - 【工厂方法模式】（Factory模式==定义一个用于创建对象的接口（工厂接口）== ，让子类决定要实例化哪一个类，工厂方法使一个类的实例化延迟到其子类）

  - 【抽象工厂模式】（Abstract Factory模式==提供一个创建一系列相关或相互依赖对象的接口==，而无需指定他们具体的类）

    注：工厂方法模式【理解：单一工厂，比如宝马工厂】，抽象工厂模式【理解：大型汽车集团，存在多个工厂，宝马工厂、奥迪工厂等等】

  - 【建造者模式】（Builder模式将==一个复杂对象的构建与其表示相分离==，这样相同的构造过程可以创建不同的对象）

  - 【原型模式】（Prototype模式允许对象在==不了解==要创建对象的确切类以及如何创建细节的情况下==创建自定义对象==）

  - 【单例模式】（Singleton模式确保==一个类只有一个实例==，并提供一个==全局访问点==来获取这个唯一实例）
- 结构型：主要用于处理类和对象的组合（共7种）。
  - 【适配器模式】（Adaptor模式==将一个复杂的组件==分成功能性抽象和内部实现两个独立又相关的继承层次结构，从而可以实现接口与实现分离）
  - 【桥接模式】(Bridge模式将==类的抽象部分和它的实现部分分离出来==，使它们可以独立变化)
  - 【组合模式】(Composite模式将对象组合成==树形结构以表示“部分-整体”的层次结构==。它使得客户对单个对象和对复合对象的==使用具有一致性==)
  - 【装饰模式】（Decorator模式==动态地给一个对象添加额外的职责==，它提供了用子类扩展功能的一个灵活替代，比派生一个子类更加灵活）
  - 【外观模式】（Facade模式要求外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式==定义了一个高层接口，这个接口使得这一子类系统更加容易使用==）
  - 【享元模式】（Flyweight模式通过==共享已存在对象，来减少创建对象的数量==，从而降低内存占用和提高性能）
  - 【代理模式】（Proxy模式==为其他对象提供一种代理以控制对这个对象的访问==，解决直接访问对象时带来的问题）
- 行为型：主要用于描述类或对象怎样交互和怎样分配职责（共11种）。
  - 【责任链模式】（Chain of Responsibility模式为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求，将这些对象行程一条链，并沿着这条链传递该请求，直到有一个对象处理它。）
  - 【命令模式】（Command模式将==一个请求封装为一个对象==，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作）
  - 【解释器模式】（Interpreter模式描述如何为语言定义一个文法，==主要用在编译器中==，在应用系统开发中很少用到）
  - 【迭代器模式】（Iterator模式提供==一种方法来访问聚合对象==，而不用暴露这个对象的内部表示）
  - 【中介者模式】（Mediator模式是通过==一个中介对象来封装一系列的对象交互==，使得各个对象之间不需要显式地相互引用，从而使其==耦合松散==，而且可以==独立地改变他们之间的交互==）
  - 【备忘录模式】（Memento模式在==不破坏封装性的前提==下，==捕获一个对象的内部状态，并在该对象之外保存这个状态==。这样以后久可以将对象恢复到原先保存的状态）
  - 【观察者模式】（Observer模式定义对象之间的一种==一对多==的依赖关系，当==一个对象的状态发生改变==时，==所有依赖==于它的对象都会得到通知并==自动更新==）
  - 【状态模式】（Status模式将每==一条件分支放入一个独立的类中==，这样可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化）
  - 【策略模式】（Strategy模式是==定义一系列算法==，将算法封装起来，并让它们可以相互替换。将行为和环境分隔，当出现新的行为时，只需要==实现新的策略类==）
  - 【模板方法模式】（Template模式==定义一个操作中的算法骨架==，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。相当于【完形填空】）
  - 【访问者模式】（Visitor模式表示==一个作用于某个对象结构中的各元素的操作==。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作）



根据==作用范围==分类：

- 类模式：用于处理类和子类的关系，这种关系通过继承，在编译时就确认了，是一种静态关系。
- 对象模式：用于处理对象间的关系，是动态关系。



### COM(组装对象模型)

- COM不支持任何形式的实现继承。
- COM支持两种形式的对象组装：==包含==和==聚集==
  - 包含：一个外部对象拥有指向一个内部对象的唯一索引，外部对象只是把请求转发给内部对象。
  - 聚集：直接把内部对象的接口引用传递给外部对象，而不再转发请求。




### 耦合和内聚

【低耦合，高内聚】

- 耦合性：从低到高【非直接耦合 --> 数据耦合 --> 特征耦合 --> 控制耦合 --> 外部耦合 --> 公共耦合 --> 内容耦合】
- 内聚性：从低到高【偶然内聚(巧合内聚) --> 逻辑内聚 --> 瞬时内聚(时间内聚) --> 过程内聚 --> 通信内聚 --> 顺序内聚 --> 功能内聚】




### UML图形

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/20250908221905387.png)



### UML图之类图

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509101607021.png)

【关系】

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509101607315.png)





### UML提供的系统视图

- 逻辑视图（设计视图）：它表示了设计模型在==架构方面==具有重要意义的部分，即类、子系统、包和用例实现的子集。
- 进程视图：它是逻辑视图的==一次执行实例==，描述了==并发与同步==结构。
- 实现视图：对组成基于系统的物理==代码==的文件和构件进行建模。
- 部署视图：把构件部署到一组==物理节点==上，表示软件到硬件的映射和分布结构。
- 用例视图：用例视是==最基本==的需求分析模型。




### UML图之顺序图

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509042104973.png)

序列片段类型：==循环、分支、选择==

对象之间的消息类型包括：==同步消息、异步消息、返回消息、参与者创建消息、参与者销毁消息==





### 软件维护类型

改正性维护【修BUG】：识别纠正软件错误/缺陷，测试不可能发现所有错误。

适应性维护【应变】：指应用软件适应环境变化【外部环境、数据环境】而进行的修改。

完善性维护【新需求】：为扩充功能和改善性能而进行的修改。

预防性维护【针对未来】：为了适应未来的软硬件环境变化，应主动增加预防性的新功能。



### 面向对象设计原则

- 单一原则：设计==目的单一==的类
- 开放-封闭原则：对扩展开放，对==修改封闭==
- 里氏替换原则：==子类可以替换父类==
- 依赖倒置原则：==要依赖于抽象，而不是具体实现==；针对接口编程，不要针对实现编程；
- 接口隔离原则：使用==多个专门的接口比使用单一的总接口==要好
- 组合重用原则：要==尽量使用组合==，而不是继承关系达到重用目的
- 迪米特法则（最少知识法则）：一个对象应当对其它对象有==尽可能少的了解==






### 软件生存周期模型

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509100944749.png)

注：

- 使用演化模型，从原型的演化分成两种，一种是==演化到产品==，一种是==抛弃式原型==，就是获得需求之后就会抛弃掉。
- 软件生存周期模型的主目标是==为了更好地管理、维护和升级软件==，其中更大的意义在于管理软件开发的步骤和方法。
- D的说法过于片面，如果软件系统直接报废了，软甲生存周期也就中断了。




### 案例题：

#### 例题一：

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/20250908221143925.png)

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/20250908221218277.png)

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509082213729.png)



#### 例题二：

 ![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/20250909210136705.png)

注：用来描述系统中每个模块的输入、输出和数据加工的是IPO图，而非流程图。



#### 例题三：

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509101623277.png)

分析：

首先Composite模式“组合模式”，证明是UML中的组合关系，直接去除FinanceDeoartment和HRDeoartment，因为它们属于“范化（继承）”关系。

在根据Composite设计模式的UML图形

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509101622476.png)

确定其：==组合的为Component角色，被组合的为Composite角色==



#### 例题四：

![](https://gitee.com/YunboCheng/image-bad/raw/master/imgs/202509101724435.png)

注：

A错：结构化分析方法一般利用图形表达用户需求，使用的手段主要有：数据流图、数据字段、结构化语言、按段表等多种模型。A说必须使用那两种，是错误的。

B正确：UML是面向对象软件的标准化建模语言，其中状态图、活动图、顺序图和通信图可以用来对系统的动态行为进行建模。

C错误：

数据库设计中，四个各阶段的产物：

- 需求分析产出物：==需求说明书==、数据流图、==数据字典==；
- 概念模型设计：概念模型、==E-R图==；
- 逻辑模型设计：逻辑模型、==关系模式==；
- 物理结构设计：数据模型的==存储结构==和==存储方法==；

D错误：UML的活动图强调对象之间的控制流程，在图中可以表示分支和汇总。和程序流程图是==不等价的==。



